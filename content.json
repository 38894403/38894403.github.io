{"meta":{"title":"Zhangce","subtitle":"简单不先于复杂，而是在复杂之后","description":"blog","author":"张策","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"1970-01-01T00:00:00.001Z","updated":"2017-02-24T09:59:13.333Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-02-06T14:14:16.000Z","updated":"2017-02-06T14:14:36.376Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2017-03-01T03:37:27.000Z","updated":"2017-03-01T03:40:31.460Z","comments":true,"path":"2017/03/01/test/","link":"","permalink":"http://yoursite.com/2017/03/01/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"函数调用","slug":"函数调用","date":"2016-12-26T12:22:09.000Z","updated":"2017-03-01T02:47:10.766Z","comments":true,"path":"2016/12/26/函数调用/","link":"","permalink":"http://yoursite.com/2016/12/26/函数调用/","excerpt":"","text":"函数的定义会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另一个值——本次调用的上下文——这就是 this 关键字。如果函数挂在在一个对象上，作为对象的一个属性，就称为它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（context），也就是该函数的this的值。在JS中，函数即对象，程序可以随意操控它们。比如，JS可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。JS的函数可以嵌套在其他函数定义中，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着JS函数构成了一个闭包（closure）,它给JS带来了非常强劲的编程能力。 什么是函数函数定义函数使用 function 关键字来定义；它可以用在函数定义表达式或者函数声明语句里。在两种形式里，函数定义都从 function 关键字开始，其后跟随这些组成部分 函数名字标识符 —— 函数名称是函数声明语句必须的部分。它的用于就像变量的名字，新定义的函数对象会赋值给这个对象。对函数定义表达式来说，这个名字是可选的；如果存在，该名字只存在与函数体中，并指代该函数对象本身。 一对圆括号 —— 其中包含由0个或者多个逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。 一对花括号 —— 其中包含0条或多条JS语句。这些语句构成了函数体；一旦调用函数，就会执行这些语句。 12345678910111213141516// 函数声明语句 function printprops(o)&#123; ... ... &#125; // 函数表达式 var square = function(x )&#123; ... ...&#125; // 函数表达式可以包含名称 var f = function fact(x) &#123; ... ...&#125;; // 函数表达式也可以作为参数传递给其他函数 data.sort(function(a,b)&#123;... ...&#125;); // 函数表达式有时定义后立即调用 var tensquared = (function(x)&#123;return x*x;&#125;(10)); 注意： 以表达式方式定义的函数，函数的名称是可选的。 一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。 相对而言，定义函数表达式时并没有声明一个变量。 如果一个函数表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称，实际上，函数的名称将会称为函数内部的一个局部变量。 以表达式方式定义的函数在定义之前无法调用 函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用&gt;函数返回值大多数函数包含一条 reuturn 语句。return语句导致函数停止执行，并返回它的表达式的值给调用者。如果return语句没有一个与之相关的表达式，则它返回undefined值。如果一个函数不包含return语句，那它就只执行函数体中每条语句，并返回undefined值给调用者。函数命名通常函数名的第一个字符为小写嵌套函数在JS里，函数可以嵌套在其他函数里。嵌套函数可以访问嵌套它们的函数的参数和变量。1234function hypotenuse(a, b)&#123; function square(x) &#123; return x*x;&#125; return Math.sqrt(square(a) + square(b)); &#125; 函数调用构成函数主体的JS代码在定义时并不会执行，只有调用该函数时，才会执行。有4中方式来调用JS函数： 作为函数 作为方法 作为构造函数 通过它们的call（）和apply（）方法间接调用函数调用以函数形式调用的函数通常不使用 this 关键字。方法调用方法调用和函数调用有一个重要的区别，即，调用上下文。属性访问表达式由两部分组成：一个对象和属性名称。在这样的方法调用表达式中，对象为调用上下文，函数体可以使用关键字 this 引用该对象。12345678910var calculator = &#123; operand1 : 1, operand2: 1, add: function()&#123; this.result = this.operand1 + this.operand2; &#125; &#125;; calculator.add(); calculator.result; //=&gt; 2 任何函数只要作为方法调用实际上都会传入一个隐式的实参 —— 这个对象。嵌套的函数不会从调用它的函数中继承this。如果想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量self来保存this。123456789101112var o = &#123; m: function()&#123; var self = this; console.log(this === o); //=&gt; true f(); function f()&#123; console.log(this === 0); // false console.log(self === o); // true &#125; &#125; &#125;; 构造函数调用果函数或者方法调用之前带有关键字new，它就构成构造函数调用。如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内。但如果构造函数没有形参，JS构造函数调用的语法是允许省略实参列表和圆括号的。12var o = new Object(); var o = new Object; 构造函数可以使用 this 关键字来引用这个新创建的对象。构造函数通常不使用 return 关键字。然而如果构造函数显示地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个对象作为调用结果。 间接调用函数也是对象，函数对象也可以包含方法，其中两个方法call() 和 apply() 可以用来间接调用函数。 函数的实参和形参JavaScript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。JavaScript函数调用甚至不检查传入形参的格式。 可选形参当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。 可变长的实参列表：实参对象当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得命名值的引用。参数对象解决了这个问题。在函数体内，标识符 arguments 是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标就能传入函数的实参值，而不用非要用通过名字来得到实参12345function f(x, y, z)&#123; if (arguments.length != 3)&#123; ... ... &#125; &#125; 第一个实参可以通过参数名x来获得，也可以通过 arguments[0] 来得到。","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Node中的url模块","slug":"Node中的url模块","date":"2016-12-06T03:23:51.000Z","updated":"2017-02-24T12:45:30.500Z","comments":true,"path":"2016/12/06/Node中的url模块/","link":"","permalink":"http://yoursite.com/2016/12/06/Node中的url模块/","excerpt":"","text":"在使用node时，通常需要使用一些第三方包，其实node有一些核心模块可以直接使用。 node的核心模块node 的核心模块path：处理文件路径。fs：操作文件系统。child_process：新建子进程。util：提供一系列实用小工具。http：提供HTTP服务器功能。url：用于解析URL。querystring：解析URL中的查询字符串。crypto：提供加密和解密功能。其他 url模块url模块的三种方法123456781.url.parse(str,true) //将字符串转成对象,第二个参数默认为false，为true时，返回的url对象中，query的属性为一个对象。2.url.format(urlObj) //用于将对象转成字符串3.url.resolve(from,to) url.resolve(\"http://whitemu.com\",\"gulu\"); /* 返回值： 'http://whitemu.com/gulu' */ url使用123456789101112131415161718var url = require('url');var str = 'http://poiu:123@127.0.0.1:3000/?name=tom#a';var urlObj = url.parse(str,true); console.log(urlObj);/* protocol: 'http:', 协议 slashes: true, 是否有// auth: 'poiu:123', 用户名和密码 host: '127.0.0.1:3000', 主机 port: '3000', 端口 hostname: '127.0.0.1',域名/IP地址 hash: '#a', 片断标识符 指向HTML页面某个DOM元素的ID search: '?name=tom', ?+查询字符串 query: &#123;name:'tom'&#125;,查询字符串 pathname: '/', 端口号和？中间的那部分 path: '/2016jsnode?name=tom', pathname+search href: 'http://poiu:123@127.0.0.1:3000/?name=tom#a' 原始的URL */","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"js阻止子元素响应父元素事件","slug":"js阻止子元素响应父元素事件","date":"2016-09-10T06:23:33.000Z","updated":"2017-03-01T03:13:29.697Z","comments":true,"path":"2016/09/10/js阻止子元素响应父元素事件/","link":"","permalink":"http://yoursite.com/2016/09/10/js阻止子元素响应父元素事件/","excerpt":"","text":"事件冒泡在一个元素上触发事件，如果此元素定义了处理程序，那么此次事件就会被捕获，根据程序进行该事件的处理。否则这个事件会根据DOM树向父节点逐级传播，如果从始至终都没有被处理，那么最终会到达document或window根元素。 阻止事件冒泡W3C标准调用事件对象的stopPropagation()方法，IE可以设置对象的cancelBubble属性为true; 在Jquery中的事件方法都带有event参数，这是一个符合W3C标准的事件对象，且兼容IE，可以使用event.stopPropagation()阻止冒泡。更简单的，直接return false;，等价于event.stopPropagation()加上event.preventDefault()。 在原生JS中，事件对象要区别对待。123456789101112131415161718function cancelEvent(e) &#123; if(e) &#123; e.stopPropagation(); //非IE &#125; else &#123; window.event.cancelBubble = true; //IE &#125;&#125;```bash## 阻止多个子元素的事件综上所述，想要链接和按钮元素不响应父节点事件，便要为所有这些元素注册事件，编写阻止事件冒泡的代码。```bashvar div = $('#div');div.click(function()&#123; // do...&#125;);div.on('click', 'a,button,input', function(event)&#123; event.stopPropagation(); // 或 return false;&#125;); 使用event对象解决123456$('#div').on('click', function(event)&#123; var tag = event.target.tagName; if(tag!='A' &amp;&amp; tag!='BUTTON' &amp;&amp; tag!='INPUT')&#123; // do... &#125;&#125;);","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"Event","slug":"Event","permalink":"http://yoursite.com/tags/Event/"}]},{"title":"Github访问慢的问题","slug":"Github访问慢的问题","date":"2016-06-23T06:54:12.000Z","updated":"2017-02-24T12:59:14.029Z","comments":true,"path":"2016/06/23/Github访问慢的问题/","link":"","permalink":"http://yoursite.com/2016/06/23/Github访问慢的问题/","excerpt":"","text":"有时候访问Github会加载很长时间，或者干脆css样式加载不出来，网上看了几篇文章，统一的解释是github的CDN被污染了(毕竟是国外网站，出点问题很正常) 解决办法 有vpn服务的可以直接使用vpn，没有vpn的，可以绕过dns解析，在本地直接绑定host。打开dns查询工具网站 http://tool.chinaz.com/dns 输入github的官网，会查询出该域名的解析 选取一个TTL值最小的ip，直接绑定到hosts文件便可解决，比如我选择192.30.253.113，TTL值为22 在hosts文件末尾添加 103.245.222.249 github.global.ssl.fastly.net 103.245.222.133 assets-cdn.github.com 然后再访问Github,问题解决","categories":[{"name":"网络问题","slug":"网络问题","permalink":"http://yoursite.com/categories/网络问题/"}],"tags":[{"name":"网络问题","slug":"网络问题","permalink":"http://yoursite.com/tags/网络问题/"}]},{"title":"JS中call()、apply()、bind()的区别","slug":"JS中call()、apply()、bind()的区别","date":"2016-06-02T02:43:21.000Z","updated":"2017-03-01T02:57:00.812Z","comments":true,"path":"2016/06/02/JS中call()、apply()、bind()的区别/","link":"","permalink":"http://yoursite.com/2016/06/02/JS中call()、apply()、bind()的区别/","excerpt":"","text":"call()、apply()作用都是一样的，简单来说就是改变当前使用该方法的对象中的this指向，指向调用方法中的thisObj对象二者的区别（第一个参数是相同的）就是call方法中传入的参数是是一个个列举出来的，而apply方法中的参数二是一个数组12345678910window.color='red';var o=&#123;color:\"blue\"&#125;;function sayColor()&#123;alert(this.color);&#125;;sayColor(); //red（全局函数，this是window）sayColor.call(this);//red(调用call方法，指定对象是this，这里的this是window，没什么意义)sayColor.call(window);//red(调用call方法，指定对象是window，没什么意义)sayColor.call(o); //blue (调用call方法，指定对象是o，所以this指代对象o，这里由原来的window指向了o)sayColor.apply(o);//blue (调用call方法，指定对象是o，所以this指代对象o，这里由原来的window指向了o) ECMAScript5中的bind()方法和前二种方法相似，bind()这个方法会创建一个函数的实例，这个实例的this值会被绑定到传递给bind()函数的值 123456function a(y)&#123;return this.x+y;&#125;;var o=&#123;x:1&#125;;var g=a.bind(o);g(2);//3 从例子中可以看出函数a绑定到对象o上了，并且返回了新的函数g，调用g时，a函数会当作对象o的方法来调用bind()这个方法是将函数绑定到某个对象上，并且返回一个新的函数，这个新函数中传入的参数都将传入被绑定的函数上。 区别在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。在说区别之前还是先总结一下三者的相似之处：1、都是用来改变函数的this对象的指向的。2、第一个参数都是this要指向的对象。3、都可以利用后续参数传参。那么他们的区别在哪里的，先看一个例子。1234567891011121314var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function() &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); &#125; &#125; var xh = &#123; name : \"小红\", gender : \"女\", age : 18 &#125; xw.say(); 函数执行，显示的肯定是小王 ， 男 ， 今年24。那么如何用xw的say方法来显示xh的数据呢。对于call可以这样：1xw.say.call(xh); 对于apply可以这样：1xw.say.apply(xh); 对于bind可以这样：1xw.say.bind(xh)(); 如果直接写xw.say.bind(xh)是不会有任何结果的，看到区别了吗？call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。那么call和apply有什么区别呢？我们把例子稍微改写一下。12345678910111213var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function(school,grade) &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade); &#125;&#125;var xh = &#123; name : \"小红\", gender : \"女\", age : 18&#125; 可以看到say方法多了两个参数，我们通过call/apply的参数进行传参。对于call来说是这样的1xw.say.call(xh,\"实验小学\",\"六年级\"); 对于apply来说是这样的1xw.say.apply(xh,[\"实验小学\",\"六年级\"]); call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。对于bind,可以像call那样传参1xw.say.bind(xh,\"实验小学\",\"六年级\")(); 但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。1xw.say.bind(xh,\"实验小学\",\"六年级\")();","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"利用border属性绘制简单图形","slug":"利用border属性绘制简单图形","date":"2016-04-02T13:33:21.000Z","updated":"2017-02-28T14:44:30.893Z","comments":true,"path":"2016/04/02/利用border属性绘制简单图形/","link":"","permalink":"http://yoursite.com/2016/04/02/利用border属性绘制简单图形/","excerpt":"","text":"平时在写网页时，border属性一般都会用来给盒子添加边框;但是通过对border做一些小小的控制，就可以实现简单的图形绘制效果如下图： 代码：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;triangle&lt;/title&gt;&lt;style type=\"text/css\"&gt; .shape &#123; float: left; margin-left: 50px; width:0; height:0; border-width: 30px; border-style:solid; border-color: transparent transparent transparent transparent ; &#125; /*三角形*/ .triangle &#123; border-bottom: 30px solid skyblue; &#125; /*标签*/ .mark &#123; border-left: 30px solid skyblue; border-top: 30px solid skyblue; border-right: 30px solid skyblue; &#125; /*直角三角形*/ .right-triangle &#123; border-left: 30px solid skyblue; border-bottom: 30px solid skyblue; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"shape triangle\"&gt;&lt;/div&gt; &lt;div class=\"shape mark\"&gt;&lt;/div&gt; &lt;div class=\"shape right-triangle\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其实原理很简单：把盒子宽高都设置为0，那么给该盒子添加一定宽度的边框，那么每条边都会像三角形一样，这时在把不需要的边设置为透明，就会有所需要的效果。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"base标签","slug":"base标签","date":"2015-06-23T01:24:12.000Z","updated":"2017-02-28T12:19:13.603Z","comments":true,"path":"2015/06/23/base标签/","link":"","permalink":"http://yoursite.com/2015/06/23/base标签/","excerpt":"","text":"base标签的两个作用HTML中有一个base标签,我们可以通过该标签将需要加载的文件路径写成相对于项目的，而不是相对于当前页面的 代码如下 12345678&lt;html&gt;&lt;head&gt;&lt;base href=\"http://static.cnblogs.com/\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"./images/logo_gray.gif\" /&gt;&lt;/body&gt;&lt;/html&gt; 我们会发现，我们用相对路径./images/logo_gray.gif加载的图片，却变成了http://static.cnblogs.com/images/logo_gray.gif的图片。base标签可以给页面的链接加上默认的路径，或者默认的打开方式。下面是一个设置默认打开方式的例子：12345678&lt;html&gt;&lt;head&gt;&lt;base target=\"_blank\" /&gt;&lt;/head&gt;&lt;/p&gt; &lt;p&gt;&lt;body&gt;&lt;a href=\"http://www.cnblogs.com\"&gt;这个页面会在新窗口打开&lt;/a&gt;&lt;a href=\"http://justany.cnblogs.com\"&gt;这个页面也会在新窗口打开&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; base标签的BUGbase标签最好不要动态写入，否则在Firefox和IE中会有一个小bug，比如对于页面http://localhost/static/test.html：123456789&lt;html&gt;&lt;head&gt;&lt;script&gt;document.write('&lt;base href=\"http://localhost/\" /&gt;');&lt;/script&gt;&lt;/head&gt;&lt;/p&gt; &lt;p&gt;&lt;body&gt;&lt;img src=\"static/1.jpg\" /&gt;&lt;/body&gt;&lt;/html&gt; Firefox和IE中会先加载http://localhost/static/static/1.jpg，然后再加载http://localhost/static/1.jpg。也就是说，他们都先尝试用相对于当前页面的路径进行加载，然后再通过base标签设置的默认路径加载。而Chrome却能正常加载。 问题分析造成这种问题的原因可能是浏览器对资源加载进行了优化，导致动态插入base标签并未生效时，就预先去加载了，结果出错，然后base标签生效于是又加载正确的资源。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"hexo博客使用图片","slug":"hexo博客使用图片","date":"2015-03-02T00:23:21.000Z","updated":"2017-03-01T03:56:33.710Z","comments":true,"path":"2015/03/02/hexo博客使用图片/","link":"","permalink":"http://yoursite.com/2015/03/02/hexo博客使用图片/","excerpt":"","text":"之前使用base64解码图片，使用简单，但是一大片编码看着很乱，在网上发现CodeFalling/hexo-asset-image插件来加载本地图片。使用方法： 1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}