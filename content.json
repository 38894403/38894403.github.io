{"meta":{"title":"Zhangce","subtitle":"简单不先于复杂，而是在复杂之后","description":"blog","author":"张策","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"1970-01-01T00:00:00.001Z","updated":"2017-02-24T09:59:13.333Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-02-06T14:14:16.000Z","updated":"2017-02-06T14:14:36.376Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Angular框架","slug":"Angular框架","date":"2017-02-13T15:21:08.000Z","updated":"2017-03-02T13:16:57.661Z","comments":true,"path":"2017/02/13/Angular框架/","link":"","permalink":"http://yoursite.com/2017/02/13/Angular框架/","excerpt":"","text":"Angular 介绍库和框架的区别 jQuery:库 库一般都是自己封装了一些方法 自己动手调用这些方法完成某些功能code $(&#39;#test&#39;).val(&#39;Hello&#39;); $(&#39;div&#39;).text(&#39;world&#39;) angular框架 框架都是提供一种规范或者模式 我们却要按照它提供的这种规则去写代码 框架会自动帮助我们去执行相应的代码. 其实可以简单的理解为：大而全的是框架，小而精的是库 AngularJs是什么 一款非常优秀的前端高级 JS 框架 最早由 Misko Hevery 等人创建 2009 年被 Google 公式收购，用于其多款产品 目前有一个全职的开发团队继续开发和维护这个库 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 Angular不推崇DOM操作，也就是说在NG中几乎找不到任何的DOM操作 angular，几乎不会使用angualr操作dom（但是angular内部肯定是使用dom来改变页面的值） Angular 主要是来做什么的，帮助我们方便的去写spa应用程序什么是AngularJs 一个前端框架，提供一种无DOM操作的编程方式，在前端页面中引入了传统在后台开发中使用的一些思想，增强代码的结构和可维护性 一个功能非常完备的前端框架，通过增强HTML的方式提供一种便捷开发Web应用程序的方式 其核心特点就是几乎无任何DOM操作，让开发人员的精力和时间全部集中于业务 MVC的特性增强了代码的结构和可维护性，应对需求的变化做出最小的改动 什么是SPA single page application的缩写 单页应用程序 原理就是：通过监视hashchange事件，根据不同的url中的锚点值，去动态的发送ajax请求去请求数据（简单的说就是不会看到页面刷新） 网站实例：music.163.com SPA的好处 响应效果好，体验好 重用资源 方便统一控制和代码重用，不想访问应用了，在入口的控制一下就可以。 扩展：如何获取url中的各部分参数，比如hash 字符串操作 正则表达式去匹配url 创建a对象12345var a=document.createElement('a');a.hreg='http://www.baidu.com?id=23#home';a.pathnamea.hasha.search 为什么要使用Angular 总结一句话：为了更少的代码，实现更强劲的功能 很多操作都需要dom操作，但是angular中没有那么多的dom操作，这是因为angular帮我们封装了，减少了我们开发人员的dom操作 一般在angular中就不会出现jquery了，因为这两种思想正好是相悖的。 上面的意义只是皮毛，它真正的意义是:angular又是一场革命，带领前端进入了MVX时代。 这就像从手工业转为机械工业一样，以前很多东西都是我么你自己手动去做，现在我们有了gulp，webpack这些自动化构建工具。 Angular的使用安装Angular 暴力安装: 手动的去github下载安装 通过工具安装:npm : npm install angularbower: bower install angular CDN 本质都为了拿到angular.js这个文件。 理解angular的整个开发流程 ng-app:告诉angular来管理页面的代码块是什么（ng-app所在元素及其子元素） ng-click : 类比成onClick，是用来为当前元素注册点击事件的 123456ng-click=\"val = (val-0) + 1\" //相当于： var add = document.getElementById('add'); add.addEventListener('click',function()&#123; &#125;) ng-model: 用来获取文本框的值,是于input的value值进行了绑定。改变ng-model的属性值对应的值，文本框的值就会改变 123ng-model = \"val\";//angular就会帮助我们去创建一个val变量 相当于: var num = document.getElementById('num').value; ng-init 指令: 用于对ng-model指定的值进行初始化操作ng-init = &quot;val = 10&quot; ng-controller：我们的业务逻辑，数据模型都要写在这里面 $scope:这个就相当于我们所画的途中的数据模型， 在它上面给以挂载变量和方法。 1表达式: &#123;&#123;&#125;&#125;，相当于模板函数中的模板输出 在大括号内部写上一个ng-model对应的文本框的值 使用AngularJS的流程1、借助npm下载到本地2、在HTML代码中引入Angular.js包3、在JS代码中通过angular.module(&#39;myApp&#39;, [])注册一个模块4、在HTML代码中将刚刚定义的模块通过ng-app=&quot;myApp&quot;指令的方式作用到一个特定的元素上5、根据当前页面的情况（业务块）划分控制器6、在HTML代码中将刚刚定义的控制器通过ng-controller=&quot;ControllerName&quot;作用到特定的元素上7、建模（根据界面原型抽象一个数据模型）得到一个视图模型（ViewModel）8、在JS代码中通过$scope暴露需要提供到页面的数据成员9、 12在HTML代码中将刚刚暴露出来的数据通过类似`ng-model/&#123;&#123;&#125;&#125;/ng-click`之类的指令绑定到特定的元素上 10、在JS中完成业务逻辑（还可以展开） JQ提高了操作DOM的开发效率 NG几乎没有任何DOM操作（不是没有，只是不用我们自己操作） NG内置一个类似JQ的东西angular.element() Angular 不提倡DOM操作，如果必须使用DOM的话，也不建议再去引用jquery Angular 核心概念 模块化 MVC-思想 指令 双向数据绑定 angular.module（模块）作用 通过模块对页面进行业务上的划分 将重复使用的指令或者过滤器之类的代码做成模块，方便复用 注意必须指定第二个参数，否则变成找到已经定义的模块 语法 angular.module(&#39;模块名&#39;,[]) 第二个参数是个数组,这个数组里的每一个元素，是我们当前模块依赖的其他模块 注意: 即便我们不依赖其他的模块，也需要传递一个空数组 因为如是不传第二个参数的话，这个方法的作用就会变为获取一个名为”模块名”的模块对象angular.module(&#39;myApp&#39;),是获取一个名为myApp的模块对象。 我们需要给ng-app指令一个属性值，这个值就是我们创建的模块名: 告诉anuglar,现在由我们自己创建的这个模块来管理页面。 angular.controller（控制器）作用 为应用中的模型设置初始状态 通过$scope对象把数据模型或者函数行为暴露给视图 监视模型的变化，做出相应的动作语法 控制器是通过模块对象来创建的: 语法: 12var app = angular.module('模块名',[])app.controller('控制器的名字',function($scope)&#123; // 在这个function里写我们具体想要执行的代码 // $scope 就是用来存储我们的数据模型. &#125;) 我们需要在页面上使用了数据模型的元素父级元素上加上ng-controller指令，并给这个指令一个属性值，这个值就是我们创建的控制器名字。 双向数据绑定(双向数据绑定) 页面文本框的值改变，导致数据模型的值发生改变， 数据模型的值的改变，反过来导致页面文本框的值的改变，这种相互影响的关系，我们起了个名词，叫作双向数据绑定。 ng-model = “” MVC思想什么是 MVC 思想 将应用程序的组成划分为三个部分：Model View Controller 模型：数据处理 视图：以友好的方式向用户展示数据 控制器：业务逻辑处理 控制器的作用就是初始化模型用的； 模型就是用于存储数据的,做一些业务逻辑的操作。 视图用于展现数据 用MVC构建应用的优势剥离开视图和逻辑之间的关系，无论怎么修改dom操作都不用修改业务逻辑代码","categories":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"JavaScript总结","slug":"JavaScript总结","date":"2017-01-16T13:33:51.000Z","updated":"2017-03-01T08:25:14.845Z","comments":true,"path":"2017/01/16/JavaScript总结/","link":"","permalink":"http://yoursite.com/2017/01/16/JavaScript总结/","excerpt":"","text":"数据类型JavaScript 是 弱类型 语言，但并不是没有类型，JavaScript可以识别下面 7 种不同类型的值： 基本数据类型 Boolean Number String null undefined Symbol Object Array RegExp Date Math …可以使用 typeof判断数据类型，操作符返回一个字符串，但并非返回的所有结果都符合预期1234567891011121314typeof false // \"boolean\"typeof .2 // \"number\"typeof NaN // \"number\"typeof '' // \"string\"typeof undefined // \"undefined\"typeof Symbol() // \"symbol\"typeof new Date() // \"object\"typeof [] // \"object\"typeof alert // \"function\"typeof null // \"object\"typeof not_defined_var // \"undefined\" 变量在应用程序中，使用变量来来为值命名。变量的名称称为 identifiers 声明 使用关键字 var ：函数作用域 使用关键字 let ：块作用域 (block scope local variable) 直接使用：全局作用域12345678910var global_var = 1;function fn () &#123; var fn_var = 2; if(fn_var &gt; 10)&#123; let block_var = 3; global_var2 = 4; //全局作用域 &#125;&#125; 只声明不赋值，变量的默认值是 undefined const关键字可以声明不可变变量，同样为块作用域。对不可变的理解在对象上的理解需要注意123456789const num = 1;const obj = &#123; prop: 'value'&#125;;num = 2; // Uncaught TypeError: Assignment to constant variable.obj['prop'] = 'value2';obj = []; // Uncaught TypeError: Assignment to constant variable. 变量提升 JavaScript中可以引用稍后声明的变量，而不会引发异，这一概念称为变量声明提升(hoisting)123console.log(a); // undefinedvar a = 2; 等同于12345var a;console.log(a);a = 2; 函数一个函数就是一个可以被外部代码调用(或者函数本身递归调用)的 子程序 定义函数 函数声明 函数表达式 Function 构造函数 箭头函数1234567function fn()&#123;&#125;var fn = function()&#123;&#125;var fn = new Function(arg1, arg2, ... argN, funcBody)var fn = (param) =&gt; &#123;&#125; arguments arguments: 一个包含了传递给当前执行函数参数的类似于数组的对象 arguments.length: 传给函数的参数的数目12345function foo() &#123; return arguments;&#125;foo(1, 2, 3); // Arguments[3] // &#123; \"0\": 1, \"1\": 2, \"2\": 3 &#125; rest123456789101112function foo(...args) &#123; return args;&#125;foo(1, 2, 3); // Array[3]// [1, 2, 3]function fn(a, b, ...args)&#123; return args;&#125;fn(1, 2, 3, 4, 5); // Array[3] // [3, 4, 5] default 函数的参数可以在定义的时候约定默认值12345678910function fn (a = 2, b = 3) &#123; return a + b;&#125;fn(2, 3); // 5fn(2); // 5fn(); // 5 对象JavaScript 中对象是可变 键控集合 (keyed collections) 定义对象 字面量 构造函数123456var obj = &#123; prop: 'value', fn: function()&#123;&#125;&#125;;var date = new Date(); 构造函数 构造函数和普通函数并没有区别，使用 new 关键字调用就是构造函数，使用构造函数可以 实例化 一个对象 函数的返回值有两种可能 显式调用 return 返回 return 后表达式的求值 没有调用 return 返回 undefined123456function People(name, age) &#123; this.name = name; this.age = age;&#125;var people = new People('Byron', 26); 构造函数返回值 没有返回值 简单数据类型 对象类型前两种情况构造函数返回构造对象的实例，实例化对象正是利用的这个特性 第三种构造函数和普通函数表现一致，返回 return 后表达式的结果 prototype 每个函数都有一个 prototype 的对象属性，对象内有一个 constructor 属性，默认指向函数本身 每个对象都有一个 __proto__的属性，属相指向其父类型的 prototype12345678910111213function Person(name) &#123; this.name = name;&#125;Person.prototype.print = function () &#123; console.log(this.name);&#125;;var p1 = new Person('Byron');var p2 = new Person('Casper');p1.print();p2.print(); this 和作用域this 场景 普通函数 严格模式：undefined 非严格模式: 全局对象 Node: global 浏览器: window构造函数：对象的实例 对象方法：对象本身 call &amp; apply fn.call(context, arg1, arg2, …, argn) fn.apply(context, args)123function isNumber(obj) &#123; return Object.prototype.toString.call(obj) === '[object Number]';&#125; Function.prototype.bind bind 返回一个新函数，函数的作用域为 bind 参数123456789function fn() &#123; this.i = 0; setInterval(function () &#123; console.log(this.i++); &#125;.bind(this), 500)&#125;fn(); () =&gt; {} 箭头函数是 ES6 提供的新特性，是简写的 函数表达式，拥有词法作用域和 this 值123456789function fn() &#123; this.i = 0; setInterval(() =&gt; &#123; console.log(this.i++); &#125;, 500)&#125;fn(); ##继承在 JavaScript 的场景，继承有两个目标，子类需要得到父类的： 对象的属性 对象的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344function inherits(child, parent) &#123; var _proptotype = Object.create(parent.prototype); _proptotype.constructor = child.prototype.constructor; child.prototype = _proptotype;&#125;function People(name, age) &#123; this.name = name; this.age = age;&#125;People.prototype.getName = function () &#123; return this.name;&#125;function English(name, age, language) &#123; People.call(this, name, age); this.language = language;&#125;inherits(English, People);English.prototype.introduce = function () &#123; console.log('Hi, I am ' + this.getName()); console.log('I speak ' + this.language);&#125;function Chinese(name, age, language) &#123; People.call(this, name, age); this.language = language;&#125;inherits(Chinese, People);Chinese.prototype.introduce = function () &#123; console.log('你好，我是' + this.getName()); console.log('我说' + this.language);&#125;var en = new English('Byron', 26, 'English');var cn = new Chinese('色拉油', 27, '汉语');en.introduce();cn.introduce(); ES6 class 与继承12345678910111213141516171819202122232425262728\"use strict\";class People&#123; constructor(name, age)&#123; this.name = name; this.age = age; &#125; getName()&#123; return this.name; &#125;&#125;class English extends People&#123; constructor(name, age, language)&#123; super(name, age); this.language = language; &#125; introduce()&#123; console.log('Hi, I am ' + this.getName()); console.log('I speak ' + this.language); &#125;&#125;let en = new English('Byron', 26, 'English');en.introduce(); 语法label statement1234567891011loop: for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 5; j++) &#123; console.log(j); if (j === 1) &#123; break loop; &#125; &#125; &#125;console.log(i); 语句与表达式12345var x = &#123; a:1 &#125;;&#123; a:1 &#125;&#123; a:1, b:2 &#125; 立即执行函数1234567891011121314151617181920( function() &#123;&#125;() );( function() &#123;&#125; )();[ function() &#123;&#125;() ];~ function() &#123;&#125;();! function() &#123;&#125;();+ function() &#123;&#125;();- function() &#123;&#125;();delete function() &#123;&#125;();typeof function() &#123;&#125;();void function() &#123;&#125;();new function() &#123;&#125;();new function() &#123;&#125;;var f = function() &#123;&#125;();1, function() &#123;&#125;();1 ^ function() &#123;&#125;();1 &gt; function() &#123;&#125;(); 高阶函数高阶函数是把函数当做参数或者返回值是函数的函数 回调函数123[1, 2, 3, 4].forEach(function(item)&#123; console.log(item);&#125;); 闭包 闭包由两部分组成 函数 环境：函数创建时作用域内的局部变量123456789101112function makeCounter(init) &#123; var init = init || 0; return function()&#123; return ++init; &#125;&#125;var counter = makeCounter(10);console.log(counter());console.log(counter()); 典型错误123456for (var i = 0; i &lt; doms.length; i++) &#123; doms.eq(i).on('click', function (ev) &#123; console.log(i); &#125;);&#125;​ 1234567for (var i = 0; i &lt; doms.length; i++) &#123; (function (i) &#123; doms.eq(i).on('click', function (ev) &#123; console.log(i); &#125;); &#125;)(i);&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Angular的双向数据绑定","slug":"Angular的双向数据绑定","date":"2017-01-04T15:01:08.000Z","updated":"2017-03-02T13:17:48.714Z","comments":true,"path":"2017/01/04/Angular的双向数据绑定/","link":"","permalink":"http://yoursite.com/2017/01/04/Angular的双向数据绑定/","excerpt":"","text":"Angular JS (Angular.JS) 是一组用来开发Web页面的框架、模板以及数据绑定和丰富UI组件。它支持整个开发进程，提供web应用的架构，无需进行手工DOM操作。 AngularJS很小，只有60K，兼容主流浏览器，与 jQuery 配合良好。双向数据绑定可能是AngularJS最酷最实用的特性,将MVC的原理展现地淋漓尽致. AngularJS的工作原理是:HTML模板将会被浏览器解析到DOM中, DOM结构成为AngularJS编译器的输入。AngularJS将会遍历DOM模板, 来生成相应的NG指令,所有的指令都负责针对view(即HTML中的ng-model)来设置数据绑定。因此, NG框架是在DOM加载完成之后, 才开始起作用的. 在html中:1234567&lt;body ng-app=\"ngApp\"&gt; &lt;div ng-controller=\"ngCtl\"&gt; &lt;label ng-model=\"myLabel\"&gt;&lt;/label&gt; &lt;input type=\"text\" ng-model=\"myInput\" /&gt; &lt;button ng-model=\"myButton\" ng-click=\"btnClicked\"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 在js中：12345678910111213// angular appvar app = angular.module(\"ngApp\", [], function()&#123; console.log(\"ng-app : ngApp\");&#125;);// angular controllerapp.controller(\"ngCtl\", [ '$scope', function($scope)&#123; console.log(\"ng-controller : ngCtl\"); $scope.myLabel = \"text for label\"; $scope.myInput = \"text for input\"; $scope.btnClicked = function() &#123; console.log(\"Label is \" + $scope.myLabel); &#125;&#125;]); 如上,我们在html中先定义一个angular的app,指定一个angular的controller,则该controller会对应于一个作用域(可以用$scope前缀来指定作用域中的属性和方法等). 则在该ngCtl的作用域内的HTML标签, 其值或者操作都可以通过$scope的方式跟js中的属性和方法进行绑定. 这样, 就实现了NG的双向数据绑定: 即HTML中呈现的view与AngularJS中的数据是一致的. 修改其一, 则对应的另一端也会相应地发生变化. 这样的方式,使用起来真的非常方便. 我们仅关心HTML标签的样式, 及其对应在js中angular controller作用域下绑定的属性和方法. 仅此而已, 将众多复杂的DOM操作全都省略掉了. 这样的思想,其实跟jQuery的DOM查询和操作是完全不一样的, 因此也有很多人建议用AngularJS的时候,不要混合使用jQuery. 当然, 二者各有优劣, 使用哪个就要看自己的选择了. NG中的app相当于一个模块module, 在每个app中可以定义多个controller, 每个controller都会有各自的作用域空间,不会相互干扰. 看下边这段html:12345&lt;div ng-app=\"dataApp\"&gt; 单价： &lt;input type=\"number\" min=0 ng-model=\"price\" ng-init=\"price = 299\"&gt;&lt;br&gt; 数量： &lt;input type=\"number\" min=0 ng-model=\"quantity\" ng-init=\"quantity = 1\"&gt;&lt;br&gt; 总价： &#123;&#123; quantity * price &#125;&#125;&lt;/div&gt; 你会惊喜地发现, 甚至不用写一行的JS代码, 即可完成计算并在界面展示结果.1即: 在前端html中使用&#123;&#123; &#125;&#125;括起来的变量, 是跟AngularJS中对应的controller作用域内的属性绑定在一起的. 实际上,&#123;&#123;&#125;&#125;等同于ng-bind指令, 即ng-bind=\"myData\"就能将NG中的myData数据跟前端对应元素绑定在一起.这样的话, 可以非常方便地做到从NG中获取任意数据并实时展示在页面上了. 另外, $scope对象还提供了一个$apply方法, 用于进行html页面上的更新, 使用方式为:123$scope.$apply(function()&#123; $scope.myValue = \"NewValue\";&#125;); $scope对象, 我们可以理解为NG框架中的一个作用域对象, 在该作用域内可以做到数据和视图的相互绑定, 同时又能与其他$scope对象的作用域隔离开来. 当然, $scope也可以实现继承, 这部分内容在以后接触NG框架中其他对象的时候再分别做记录.","categories":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/categories/Angular/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"函数调用","slug":"函数调用","date":"2016-12-26T12:22:09.000Z","updated":"2017-03-01T02:47:10.766Z","comments":true,"path":"2016/12/26/函数调用/","link":"","permalink":"http://yoursite.com/2016/12/26/函数调用/","excerpt":"","text":"函数的定义会为形参提供实参的值。函数使用它们实参的值来计算返回值，称为该函数调用表达式的值。除了实参之外，每次调用还会拥有另一个值——本次调用的上下文——这就是 this 关键字。如果函数挂在在一个对象上，作为对象的一个属性，就称为它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（context），也就是该函数的this的值。在JS中，函数即对象，程序可以随意操控它们。比如，JS可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。JS的函数可以嵌套在其他函数定义中，这样它们就可以访问它们被定义时所处的作用域中的任何变量。这意味着JS函数构成了一个闭包（closure）,它给JS带来了非常强劲的编程能力。 什么是函数函数定义函数使用 function 关键字来定义；它可以用在函数定义表达式或者函数声明语句里。在两种形式里，函数定义都从 function 关键字开始，其后跟随这些组成部分 函数名字标识符 —— 函数名称是函数声明语句必须的部分。它的用于就像变量的名字，新定义的函数对象会赋值给这个对象。对函数定义表达式来说，这个名字是可选的；如果存在，该名字只存在与函数体中，并指代该函数对象本身。 一对圆括号 —— 其中包含由0个或者多个逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。 一对花括号 —— 其中包含0条或多条JS语句。这些语句构成了函数体；一旦调用函数，就会执行这些语句。 12345678910111213141516// 函数声明语句 function printprops(o)&#123; ... ... &#125; // 函数表达式 var square = function(x )&#123; ... ...&#125; // 函数表达式可以包含名称 var f = function fact(x) &#123; ... ...&#125;; // 函数表达式也可以作为参数传递给其他函数 data.sort(function(a,b)&#123;... ...&#125;); // 函数表达式有时定义后立即调用 var tensquared = (function(x)&#123;return x*x;&#125;(10)); 注意： 以表达式方式定义的函数，函数的名称是可选的。 一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。 相对而言，定义函数表达式时并没有声明一个变量。 如果一个函数表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称，实际上，函数的名称将会称为函数内部的一个局部变量。 以表达式方式定义的函数在定义之前无法调用 函数声明语句被提前到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用&gt;函数返回值大多数函数包含一条 reuturn 语句。return语句导致函数停止执行，并返回它的表达式的值给调用者。如果return语句没有一个与之相关的表达式，则它返回undefined值。如果一个函数不包含return语句，那它就只执行函数体中每条语句，并返回undefined值给调用者。函数命名通常函数名的第一个字符为小写嵌套函数在JS里，函数可以嵌套在其他函数里。嵌套函数可以访问嵌套它们的函数的参数和变量。1234function hypotenuse(a, b)&#123; function square(x) &#123; return x*x;&#125; return Math.sqrt(square(a) + square(b)); &#125; 函数调用构成函数主体的JS代码在定义时并不会执行，只有调用该函数时，才会执行。有4中方式来调用JS函数： 作为函数 作为方法 作为构造函数 通过它们的call（）和apply（）方法间接调用函数调用以函数形式调用的函数通常不使用 this 关键字。方法调用方法调用和函数调用有一个重要的区别，即，调用上下文。属性访问表达式由两部分组成：一个对象和属性名称。在这样的方法调用表达式中，对象为调用上下文，函数体可以使用关键字 this 引用该对象。12345678910var calculator = &#123; operand1 : 1, operand2: 1, add: function()&#123; this.result = this.operand1 + this.operand2; &#125; &#125;; calculator.add(); calculator.result; //=&gt; 2 任何函数只要作为方法调用实际上都会传入一个隐式的实参 —— 这个对象。嵌套的函数不会从调用它的函数中继承this。如果想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量self来保存this。123456789101112var o = &#123; m: function()&#123; var self = this; console.log(this === o); //=&gt; true f(); function f()&#123; console.log(this === 0); // false console.log(self === o); // true &#125; &#125; &#125;; 构造函数调用果函数或者方法调用之前带有关键字new，它就构成构造函数调用。如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内。但如果构造函数没有形参，JS构造函数调用的语法是允许省略实参列表和圆括号的。12var o = new Object(); var o = new Object; 构造函数可以使用 this 关键字来引用这个新创建的对象。构造函数通常不使用 return 关键字。然而如果构造函数显示地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个对象作为调用结果。 间接调用函数也是对象，函数对象也可以包含方法，其中两个方法call() 和 apply() 可以用来间接调用函数。 函数的实参和形参JavaScript中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。JavaScript函数调用甚至不检查传入形参的格式。 可选形参当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。 可变长的实参列表：实参对象当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得命名值的引用。参数对象解决了这个问题。在函数体内，标识符 arguments 是指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标就能传入函数的实参值，而不用非要用通过名字来得到实参12345function f(x, y, z)&#123; if (arguments.length != 3)&#123; ... ... &#125; &#125; 第一个实参可以通过参数名x来获得，也可以通过 arguments[0] 来得到。","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Node中的url模块","slug":"Node中的url模块","date":"2016-12-06T03:23:51.000Z","updated":"2017-02-24T12:45:30.500Z","comments":true,"path":"2016/12/06/Node中的url模块/","link":"","permalink":"http://yoursite.com/2016/12/06/Node中的url模块/","excerpt":"","text":"在使用node时，通常需要使用一些第三方包，其实node有一些核心模块可以直接使用。 node的核心模块node 的核心模块path：处理文件路径。fs：操作文件系统。child_process：新建子进程。util：提供一系列实用小工具。http：提供HTTP服务器功能。url：用于解析URL。querystring：解析URL中的查询字符串。crypto：提供加密和解密功能。其他 url模块url模块的三种方法123456781.url.parse(str,true) //将字符串转成对象,第二个参数默认为false，为true时，返回的url对象中，query的属性为一个对象。2.url.format(urlObj) //用于将对象转成字符串3.url.resolve(from,to) url.resolve(\"http://whitemu.com\",\"gulu\"); /* 返回值： 'http://whitemu.com/gulu' */ url使用123456789101112131415161718var url = require('url');var str = 'http://poiu:123@127.0.0.1:3000/?name=tom#a';var urlObj = url.parse(str,true); console.log(urlObj);/* protocol: 'http:', 协议 slashes: true, 是否有// auth: 'poiu:123', 用户名和密码 host: '127.0.0.1:3000', 主机 port: '3000', 端口 hostname: '127.0.0.1',域名/IP地址 hash: '#a', 片断标识符 指向HTML页面某个DOM元素的ID search: '?name=tom', ?+查询字符串 query: &#123;name:'tom'&#125;,查询字符串 pathname: '/', 端口号和？中间的那部分 path: '/2016jsnode?name=tom', pathname+search href: 'http://poiu:123@127.0.0.1:3000/?name=tom#a' 原始的URL */","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"js阻止子元素响应父元素事件","slug":"js阻止子元素响应父元素事件","date":"2016-09-10T06:23:33.000Z","updated":"2017-03-01T03:13:29.697Z","comments":true,"path":"2016/09/10/js阻止子元素响应父元素事件/","link":"","permalink":"http://yoursite.com/2016/09/10/js阻止子元素响应父元素事件/","excerpt":"","text":"事件冒泡在一个元素上触发事件，如果此元素定义了处理程序，那么此次事件就会被捕获，根据程序进行该事件的处理。否则这个事件会根据DOM树向父节点逐级传播，如果从始至终都没有被处理，那么最终会到达document或window根元素。 阻止事件冒泡W3C标准调用事件对象的stopPropagation()方法，IE可以设置对象的cancelBubble属性为true; 在Jquery中的事件方法都带有event参数，这是一个符合W3C标准的事件对象，且兼容IE，可以使用event.stopPropagation()阻止冒泡。更简单的，直接return false;，等价于event.stopPropagation()加上event.preventDefault()。 在原生JS中，事件对象要区别对待。123456789101112131415161718function cancelEvent(e) &#123; if(e) &#123; e.stopPropagation(); //非IE &#125; else &#123; window.event.cancelBubble = true; //IE &#125;&#125;```bash## 阻止多个子元素的事件综上所述，想要链接和按钮元素不响应父节点事件，便要为所有这些元素注册事件，编写阻止事件冒泡的代码。```bashvar div = $('#div');div.click(function()&#123; // do...&#125;);div.on('click', 'a,button,input', function(event)&#123; event.stopPropagation(); // 或 return false;&#125;); 使用event对象解决123456$('#div').on('click', function(event)&#123; var tag = event.target.tagName; if(tag!='A' &amp;&amp; tag!='BUTTON' &amp;&amp; tag!='INPUT')&#123; // do... &#125;&#125;);","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"Event","slug":"Event","permalink":"http://yoursite.com/tags/Event/"}]},{"title":"Flex布局","slug":"Flex布局","date":"2016-07-25T14:03:31.000Z","updated":"2017-03-01T09:59:10.059Z","comments":true,"path":"2016/07/25/Flex布局/","link":"","permalink":"http://yoursite.com/2016/07/25/Flex布局/","excerpt":"","text":"Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。任何一个容器都可以指定为Flex布局。123456#box&#123; display: flex; width: 500px; height: 300px; border: 10px solid red;&#125; 父容器属性有六个属性设置在box父容器上，来控制子元素的显示方式；分别是： flex-direction 设置主轴对齐方式 默认 row x轴从左到右； flex-wrap 子元素换行的方式 默认nowrap ； flex-flow flex-direction和flex-wrap的简写 默认row nowrap； justify-content 子元素的对齐方式 默认flex-start 左对齐 align-items align-content flex-direction决定主轴的对齐方向，分别有四个属性： row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。1234567891011121314151617#box&#123; display: flex; flex-direction: row;&#125;.inner&#123; width: 100px; height: 100px; background: #8a4182; margin: 10px;&#125;&lt;div id=\"box\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 例如上面代码，主轴就是x轴横向的；起点在左端，从左到右排列 flex-wrap定义子元素超过一行，如何换行，分别有三个属性： nowrap（默认值）：默认不换行。 wrap：换行，第二行在第一行下面，从左到右 wrap-reverse：换行，第二行在第一行上面，从左到右； nowrap不换行，如果子元素超过父元素的宽度或者高度，会自动在主轴方向压缩下面的例子，主轴是x轴，默认不换行，但是父元素的宽度是500，子元素明显大于父元素宽度，会默认宽度变窄；123456#box&#123; display: flex; flex-direction: row; width: 500px; border: 1px solid red;&#125; wrap换行，正常的折行12345#box&#123; display: flex; flex-direction: row; flex-wrap: wrap;&#125; wrap-reverse第二行在第一行上方12345#box&#123; display: flex; flex-direction: row; flex-wrap: wrap-reverse;&#125; flex-flow是flex-direction 和flex-wrap的简写形式，默认是 row nowrapflex-flow：flex-direction|flex-wrap; justify-content子元素在主轴对齐方式 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。flex-start和flex-end，center这三个都比较简单，主要区分开下面的space-between和space-around； space-between：两端对齐 space-around align-items交叉轴如何对齐，如果flex-direction：row和row-reverse 那么交叉轴就是y轴，如果是column和column-reverse那么交叉轴是x轴 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。. baseline:以第一个子元素文字的基线对齐 . stretch:子元素不设置高度，那么高度将沾满整个父元素 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 子元素属性有六个属性设置在子元素项目上： order flex-grow flex-shrink flex-basis flex align-selforder子元素排列的位置默认是按照html先后顺序来排列的，html结构谁在前面默认就排列在前面；order的作用就是改变子元素排列顺序order：默认（0） 值越小越靠前，1234567891011&lt;div id=\"box\"&gt; &lt;div class=\"inner item\"&gt;1&lt;/div&gt; &lt;div class=\"inner\"&gt;2&lt;/div&gt; &lt;div class=\"inner\"&gt;3&lt;/div&gt; &lt;div class=\"inner\"&gt;4&lt;/div&gt; &lt;div class=\"inner\"&gt;5&lt;/div&gt;&lt;/div&gt;.inner:nth-child(5)&#123; order: -1;&#125; flex-grow放大比例 默认是0 当有放大空间的时候，值越大，放大的比例越大123.inner:nth-child(1)&#123; flex-grow: 1; &#125; flex-shrink缩小比例 默认是1 值越大，缩小的时候比例越小； flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex-basis：200px ，如果项目有多余的空间，设置为200px。那么会放大到200的宽度； flex flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 除了auto是表示继承父元素，其他的跟align-items是一样的。","categories":[{"name":"Flex布局","slug":"Flex布局","permalink":"http://yoursite.com/categories/Flex布局/"}],"tags":[{"name":"Flex布局","slug":"Flex布局","permalink":"http://yoursite.com/tags/Flex布局/"},{"name":"弹性布局","slug":"弹性布局","permalink":"http://yoursite.com/tags/弹性布局/"}]},{"title":"Github访问慢的问题","slug":"Github访问慢的问题","date":"2016-06-23T06:54:12.000Z","updated":"2017-02-24T12:59:14.029Z","comments":true,"path":"2016/06/23/Github访问慢的问题/","link":"","permalink":"http://yoursite.com/2016/06/23/Github访问慢的问题/","excerpt":"","text":"有时候访问Github会加载很长时间，或者干脆css样式加载不出来，网上看了几篇文章，统一的解释是github的CDN被污染了(毕竟是国外网站，出点问题很正常) 解决办法 有vpn服务的可以直接使用vpn，没有vpn的，可以绕过dns解析，在本地直接绑定host。打开dns查询工具网站 http://tool.chinaz.com/dns 输入github的官网，会查询出该域名的解析 选取一个TTL值最小的ip，直接绑定到hosts文件便可解决，比如我选择192.30.253.113，TTL值为22 在hosts文件末尾添加 103.245.222.249 github.global.ssl.fastly.net 103.245.222.133 assets-cdn.github.com 然后再访问Github,问题解决","categories":[{"name":"网络问题","slug":"网络问题","permalink":"http://yoursite.com/categories/网络问题/"}],"tags":[{"name":"网络问题","slug":"网络问题","permalink":"http://yoursite.com/tags/网络问题/"}]},{"title":"JS中call()、apply()、bind()的区别","slug":"JS中call()、apply()、bind()的区别","date":"2016-06-02T02:43:21.000Z","updated":"2017-03-01T02:57:00.812Z","comments":true,"path":"2016/06/02/JS中call()、apply()、bind()的区别/","link":"","permalink":"http://yoursite.com/2016/06/02/JS中call()、apply()、bind()的区别/","excerpt":"","text":"call()、apply()作用都是一样的，简单来说就是改变当前使用该方法的对象中的this指向，指向调用方法中的thisObj对象二者的区别（第一个参数是相同的）就是call方法中传入的参数是是一个个列举出来的，而apply方法中的参数二是一个数组12345678910window.color='red';var o=&#123;color:\"blue\"&#125;;function sayColor()&#123;alert(this.color);&#125;;sayColor(); //red（全局函数，this是window）sayColor.call(this);//red(调用call方法，指定对象是this，这里的this是window，没什么意义)sayColor.call(window);//red(调用call方法，指定对象是window，没什么意义)sayColor.call(o); //blue (调用call方法，指定对象是o，所以this指代对象o，这里由原来的window指向了o)sayColor.apply(o);//blue (调用call方法，指定对象是o，所以this指代对象o，这里由原来的window指向了o) ECMAScript5中的bind()方法和前二种方法相似，bind()这个方法会创建一个函数的实例，这个实例的this值会被绑定到传递给bind()函数的值 123456function a(y)&#123;return this.x+y;&#125;;var o=&#123;x:1&#125;;var g=a.bind(o);g(2);//3 从例子中可以看出函数a绑定到对象o上了，并且返回了新的函数g，调用g时，a函数会当作对象o的方法来调用bind()这个方法是将函数绑定到某个对象上，并且返回一个新的函数，这个新函数中传入的参数都将传入被绑定的函数上。 区别在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。在说区别之前还是先总结一下三者的相似之处：1、都是用来改变函数的this对象的指向的。2、第一个参数都是this要指向的对象。3、都可以利用后续参数传参。那么他们的区别在哪里的，先看一个例子。1234567891011121314var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function() &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); &#125; &#125; var xh = &#123; name : \"小红\", gender : \"女\", age : 18 &#125; xw.say(); 函数执行，显示的肯定是小王 ， 男 ， 今年24。那么如何用xw的say方法来显示xh的数据呢。对于call可以这样：1xw.say.call(xh); 对于apply可以这样：1xw.say.apply(xh); 对于bind可以这样：1xw.say.bind(xh)(); 如果直接写xw.say.bind(xh)是不会有任何结果的，看到区别了吗？call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。那么call和apply有什么区别呢？我们把例子稍微改写一下。12345678910111213var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function(school,grade) &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade); &#125;&#125;var xh = &#123; name : \"小红\", gender : \"女\", age : 18&#125; 可以看到say方法多了两个参数，我们通过call/apply的参数进行传参。对于call来说是这样的1xw.say.call(xh,\"实验小学\",\"六年级\"); 对于apply来说是这样的1xw.say.apply(xh,[\"实验小学\",\"六年级\"]); call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。对于bind,可以像call那样传参1xw.say.bind(xh,\"实验小学\",\"六年级\")(); 但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。1xw.say.bind(xh,\"实验小学\",\"六年级\")();","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"初学Bootstrap","slug":"初学Bootstrap","date":"2016-05-02T07:20:01.000Z","updated":"2017-03-01T07:21:33.023Z","comments":true,"path":"2016/05/02/初学Bootstrap/","link":"","permalink":"http://yoursite.com/2016/05/02/初学Bootstrap/","excerpt":"","text":"bootstrap 的学习非常简单，并且它所提供的样式又非常精美。只要稍微简单的学习就可以制作出漂亮的页面。 Bootstrap引用bootstrap提供了三种类型的下载： 用于生产环境的 Bootstrap 编译并压缩后的 CSS、JavaScript 和字体文件。不包含文档和源码文件。 Bootstrap 源码 Less、JavaScript 和 字体文件的源码，并且带有文档。需要 Less 编译器和一些设置工作。 Sass 这是 Bootstrap 从 Less 到 Sass 的源码移植项目，用于快速地在 Rails、Compass 或 只针对 Sass 的项目中引入。 其实我们不用下载bootstrap也可以使用它： Bootstrap 中文网 为 Bootstrap 专门构建了自己的免费 CDN 加速服务。基于国内云厂商的 CDN 服务，访问速度更快、加速效果更明显、没有速度和带宽限制、永久免费。下面是base.html12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，bootstrap！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src=\"http://cdn.bootcss.com/jquery/1.11.2/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=\"http://cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; base.html中已经引入了bootstrap，将其保存，就可以使用bootstrap提供的样式了。 图标字体bootstrap默认提供了二百多个图标。我们可以通过span标签来使用这些图标：12345678&lt;h3&gt;图标&lt;/h3&gt; &lt;span class=\"glyphicon glyphicon-home\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-signal\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-cog\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-apple\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-trash\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-play-circle\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-headphones\"&gt;&lt;/span&gt; 图标 按钮标签用于创建按钮，bootstrap提供了丰富的按钮样式。12345678910111213141516&lt;h3&gt;按钮&lt;/h3&gt; &lt;button type=\"button\" class=\"btn btn-default\"&gt;按钮&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;primary&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-success\"&gt;success&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-info\"&gt;info&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-warning\"&gt;warning&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-danger\"&gt;danger&lt;/button&gt; &lt;h3&gt;按钮尺寸&lt;/h3&gt; &lt;button type=\"button\" class=\"btn btn-default\"&gt;按钮&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary btn-lg\"&gt;primary&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-success btn-sm\"&gt;success&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-info btn-xs\"&gt;info&lt;/button&gt; &lt;h3&gt;把图标显示在按钮里&lt;/h3&gt; &lt;button type=\"button\" class=\"btn btn-default\"&gt;&lt;span class=\"glyphicon glyphicon-home\"&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;按钮&lt;/button&gt; 按钮除了有默认的大小外，bootstrap还提供三个参数来调整按钮的大小，分别是：btn-lg、btn-sm和btn-xs。 按钮 下拉菜单 下拉菜单是最常见的交互之一，bootstrap提供了漂亮的样式。12345678910111213&lt;h3&gt;下拉菜单&lt;/h3&gt; &lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-primary dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\" aria-expanded=\"true\"&gt; Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 输入框通过&lt;input&gt;&lt;/input&gt;标签去创建输入框。12345678910&lt;h3&gt;输入框&lt;/h3&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt; &lt;input type=\"text\" placeholder=\"username\"&gt; &lt;/div&gt; &lt;div class=\"input-group\"&gt; &lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt; &lt;input type=\"password\" placeholder=\"password\"&gt; &lt;/div&gt; 输入框 导航栏123456789101112131415161718192021&lt;h3&gt;导航栏&lt;/h3&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\"&gt; &lt;div id=\"navbar\" class=\"navbar-collapse collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li class=\"dropdown-header\"&gt;Nav header&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!--/.nav-collapse --&gt; &lt;/div&gt; &lt;/nav&gt; 导航栏 表单12345678910111213141516171819202122&lt;h3&gt;表单&lt;/h3&gt; &lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;span class=\"glyphicon glyphicon-user\"&gt;&lt;/span&gt; &lt;input type=\"email\" id=\"exampleInputEmail1\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;span class=\"glyphicon glyphicon-lock\"&gt;&lt;/span&gt; &lt;input type=\"password\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputFile\"&gt;File input&lt;/label&gt; &lt;input type=\"file\" id=\"exampleInputFile\"&gt; &lt;p class=\"help-block\"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; 警告框1234567891011121314151617&lt;h3&gt;警告框&lt;/h3&gt; &lt;div class=\"alert alert-warning alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;strong&gt;Warning!&lt;/strong&gt; Better check yourself, you're not looking too good. &lt;/div&gt; &lt;div class=\"alert alert-success\" role=\"alert\"&gt; &lt;a href=\"#\" class=\"alert-link\"&gt;success!&lt;/a&gt; &lt;/div&gt; &lt;div class=\"alert alert-info\" role=\"alert\"&gt; &lt;a href=\"#\" class=\"alert-link\"&gt;info!&lt;/a&gt; &lt;/div&gt; &lt;div class=\"alert alert-warning\" role=\"alert\"&gt; &lt;a href=\"#\" class=\"alert-link\"&gt;warning!&lt;/a&gt; &lt;/div&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt; &lt;a href=\"#\" class=\"alert-link\"&gt;danger!&lt;/a&gt; &lt;/div&gt; 警告框 进度条123456&lt;h3&gt;进度条&lt;/h3&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"70\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 60%;\"&gt; 70% &lt;/div&gt; &lt;/div&gt; 进度条","categories":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/categories/Bootstrap/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"利用border属性绘制简单图形","slug":"利用border属性绘制简单图形","date":"2016-04-02T13:33:21.000Z","updated":"2017-02-28T14:44:30.893Z","comments":true,"path":"2016/04/02/利用border属性绘制简单图形/","link":"","permalink":"http://yoursite.com/2016/04/02/利用border属性绘制简单图形/","excerpt":"","text":"平时在写网页时，border属性一般都会用来给盒子添加边框;但是通过对border做一些小小的控制，就可以实现简单的图形绘制效果如下图： 代码：1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;triangle&lt;/title&gt;&lt;style type=\"text/css\"&gt; .shape &#123; float: left; margin-left: 50px; width:0; height:0; border-width: 30px; border-style:solid; border-color: transparent transparent transparent transparent ; &#125; /*三角形*/ .triangle &#123; border-bottom: 30px solid skyblue; &#125; /*标签*/ .mark &#123; border-left: 30px solid skyblue; border-top: 30px solid skyblue; border-right: 30px solid skyblue; &#125; /*直角三角形*/ .right-triangle &#123; border-left: 30px solid skyblue; border-bottom: 30px solid skyblue; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"shape triangle\"&gt;&lt;/div&gt; &lt;div class=\"shape mark\"&gt;&lt;/div&gt; &lt;div class=\"shape right-triangle\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其实原理很简单：把盒子宽高都设置为0，那么给该盒子添加一定宽度的边框，那么每条边都会像三角形一样，这时在把不需要的边设置为透明，就会有所需要的效果。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"常用CSS优化","slug":"常用CSS优化","date":"2016-03-15T14:40:51.000Z","updated":"2017-03-01T08:44:56.050Z","comments":true,"path":"2016/03/15/常用CSS优化/","link":"","permalink":"http://yoursite.com/2016/03/15/常用CSS优化/","excerpt":"","text":"关于CSS的优化工作主要从两个方面着手 网络性能：把CSS写到字节数最少，加快下载速度，自然可以让页面渲染的更快一些 语法性能：同样都能实现某些效果，但并不是所有的方式效果都相同，我们看过不少关于JavaScript方面的语法优化知识，其实CSS里面也有一些CSS压缩 CSS压缩并不是什么高端的姿势，但却很有用，其原理很简单，就是把我们CSS中没用的空白符等删去，达到缩减字符个数的目的 我们有这样一段CSS脚本1234.test&#123; background-color:#ffffff; background-image:url(a.jpg);&#125; 经过压缩后会变成这样1.test&#123; background-color:#fff; background-image:url(a.jpg)&#125; 当然高级些的压缩工具也会帮我们优化一些语法，提供很多选项，让我们的压缩更有控制，之前在的公司不采用CSS压缩，所以我没有什么实践经验，自己写东西常用的是YUI Compressor，有很多在线版的很方便 gzip压缩Gzip是一种流行的文件压缩算法，现在的应用十分广泛，尤其是在Linux平台，这个不止是对CSS，当应用Gzip压缩到一个纯文本文件时，效果是非常明显的，大约可以减少70％以上的文件大小（这取决于文件中的内容）。想进一步了解gzip看看维基百科。 在没有gzip压缩的情况下，Web服务器直接把html页面、CSS脚本、js脚本发送给浏览器，而支持gzip的Web服务器将把文件压缩后再发给浏览器，浏览器（支持gzip）在本地进行解压和解码，并显示原文件。这样我们传输的文件字节数减少了，自然可以达到网络性能优化的目的。gzip压缩需要服务器的支持，所以我们需要在服务器端进行配置 当然除了gzip压缩，缓存也是我们需要注意的，这和CSS优化关系不大了，在说web优化的时候再说 合写CSS除了压缩的方式，我们还可以通过少写CSS属性来达到减少CSS字节的目的，拿个最常见的例子 123456.test&#123; background-color: #000; background-image: url(image.jpg); background-position: left top; background-repeat: no-repeat;&#125; 我们可以改写一下上面的CSS，达到同样的效果123.test&#123; background: #000 url(image.jpg) top left no-repeat;&#125; 在CSS中还有很多类似的属性可以合写 font123&#123;font-style: oblique; font-weight: bold; font-size: 16px; font-family: Helvetica, Arial, Sans-Serif;&#125;&#123;font: oblique bold 16px Helvetica, Arial, Sans-Serif;&#125; margin/padding123&#123;margin-top: 5px; margin-right: 10px; margin-bottom: 20px; margin-left: 15px;&#125;&#123;margin: 5px 10px 20px 15px;&#125; 1234567&#123;padding-top: 5px; padding-right: 10px; padding-bottom: 5px; padding-left: 10px;&#125;&#123;padding: 5px 10px&#125;&#123;padding-top: 5px; padding-right: 5px; padding-bottom: 5px; padding-left: 5px;&#125;&#123;padding:5px;&#125; background123&#123;background-color: #000; background-image: url(image.jpg); background-position: left top; background-repeat: no-repeat;&#125;&#123;background: #000 url(image.jpg) top left no-repeat;&#125; border123456&#123;border-width: 2px; border-style: solid; border-color: #000;&#125;&#123;border: 2px solid #000;&#125;&#123;border-top: 2px; border-right: 5px; border-left: 10px; border-bottom: 3px;&#125;&#123;border: 2px 5px 10px 3px;&#125; 另外CSS3添加的很多属性如transform、animation相关的都可以合写，不一一列举，大家用的时候要注意 利用继承CSS的继承机制也可以帮我们再一定程度上缩减字节数，我们知道CSS有很多属性是可以继承的即在父容器设置了默写属性，子容器会默认也使用这些属性，因此如果我们希望全文字体尺寸是14px，大可不必为每个容器设置，只需要在body上设置就可以了。应用这个技巧，把CSS属性在可能的情况下提到父容器是可以帮我们节省CSS字节的，顺便说一下哪些属性可以继承 所有元素可继承：visibility和cursor 内联元素和块元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction 块状元素可继承：text-indent和text-align列表元素可继承：list-style、list-style-type、list-style-position、list-style-image 表格元素可继承：border-collapse 不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi 抽离、拆分CSS，不加载所有CSS抽离CSS是指把一些通用的CSS放到一个文件内，而不是写道各个页面，这样一次下载后，其它页面用到的时候就可以利用缓存了，减少不必要的重复下载。 应用抽离原则，在很多时候我们把页面通用的CSS写到了一个文件，这样加载一次后就可以利用缓存，但这样做并不适合所有场景，以前我写CSS把一些前端插件用的CSS全写到了一个页面，但是有时候页面只会用一个Dialog、有的页面只用到了一个TreeView，但却把十多个插件的CSS都下载到了页面，这就是问题了，所以虽然把CSS写道一个文件可以减少http请求，但像刚才的这种情况是不应该这样做的，对一些所有页面都会用到的我们可以这样做，所以我们在抽离和拆分的时候可要想好了。 CSS放在head中，减少repaint和reflow相信做web的同学都知道这条建议，但为什么CSS放在页面顶部有利于网页优化呢？浏览器渲染页面大概是这样的，当浏览器从上到下一边下载html生成DOM tree一边根据浏览器默认及现有CSS生成render tree来渲染页面，当遇到新的CSS的时候下载并结合现有CSS重新生成render tree，刚才的渲染工作就白费了，如果我们把所有CSS都放到页面顶部，这样就没有重新渲染的过程了。 类似的我们知道了这个也应该在脚本中注意尽量减少repaint和reflow，什么情况会导致这两种情况呢 reflow：当DOM元素出现隐藏／显示、尺寸变化、位置变化的时候都会让浏览器重新渲染页面，之前渲染工作白费了 repaint：当元素的背景颜色、边框颜色不引起reflow的变化是会让浏览器重新渲染该元素。貌似还可以接受，但如果我们在开始就定义好了，不让浏览器重复工作就更好了。 不用CSS表达式 无论怎样生成的CSS，最终我们放到页面上得是静态普通文本，没有变量、计算神马的，CSS表达式是一种动态设置CSS属性的东东，被IE5-IE8支持，看一个大家常用的例子123body &#123; background-color: expression((new Date()).getHours()%2?\"#B8D4FF\":\"#F08A00\");&#125; 这样我们赋予了CSS类似JavaScript的功能，CSS表达式非常强大，甚至可以使用CSS表达式实现 min-width 属性，隔行换色，模拟 :hover, :before, :after 等伪类，看起来能解决很多IE下的浏览器兼容性等问题，但是其带来的副作用超出我们的想象，这条CSS规则并不是只运行一次，为了确保有效性，CSS表达式会进行频繁的求值，当改变窗口大小，滚动页面甚至移动鼠标都会触发表达式进行求值，如此频繁的求值以至于浏览器的性能收到严重的影响。据《高性能网站建设建议》中的测试其执行次数远远超出我们想象，感兴趣同学可以进去看看，我们的建议就试尽量避免甚至不要使用CSS表达式。 不乱用CSS reset或属性设置在网站建设中我们经常使用一些CSS reset，达到跨浏览器统一的目的，但是很多时候我们的CSS reset过于臃肿，主要有两个问题 把很多浏览器对元素的默认属性有设置了一边，比如div的padding和margin为0啊什么的，这是没有必要的 把一些很不常用的元素的设置也写进了CSS reset，如 ruby这样的元素 避免适用通配符或隐式通配符CSS中的*代表通配符，虽然好用但使用不当这也是一个恶魔，比如1body * &#123;padding:0;margin:0;&#125; 我们以为这是对body的子结点都设置一些属性，但因为CSS继承特性的原因，页面所有元素都会接受这个规则，对于复杂的页面在性能上的影响还是很大的，这并不是说不能使用通配符，而是说使用的时候要注意范围。相信这个规则大家都知道，但是有一些隐式的通配符也需要我们的注意，比如123:visible&#123; padding:0;&#125; 这样的几乎就和通配符一样，在使用的时候一定要注意范围限制问题 避免层级或过度限制的CSS估计web开发的同学都看过MDN上Writing efficient CSS或者其各种翻译版本，文中总结了几点在书写CSS selector的意见，搞明白文中建议的一个前提是得知道CSS是从右到左解析的，而不是我们认为的从左到右，关于为什么这样做肯定是因为高效，不明就里的同学可以上网搜一下相关知识 不要用标签或 class 来限制 ID 规则 这个应该是个常识，但很多同学都会误用，写出#test.info或者div#test这样的选择器，这个只能说是画蛇添足，id已经可以唯一而且最快的定位一个元素了 不要用标签名限制 class 规则 这个估计被误用的更多，如div.info这样的写法，其实我们可以直接写为.info，从右到左解析的原因可以知道为什么其低效，如果直接使用class不能达到目的，一般情况下应该是class设计的有问题，CSS需要重构了 尽量使用最具体的类别、避免后代选择器、属于标签类别的规则永远不要包含子选择器 这三条规则是想通的，因为从左到右解析关系，在CSS选择器中后代选择器非但没有帮我们加快CSS查找，反而后代选择器是 CSS 中耗费最昂贵的选择器。 它的耗费是极其昂贵的—特别是当选择器在标签或通用类别中，作者给的建议是当使用子选择器时要十分谨慎，能免则免。其开销可见一斑了。 对此我们可以通过具体类别——使用单一或尽量少的class解决。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"经典电影排行","slug":"经典电影排行","date":"2016-02-06T10:11:57.000Z","updated":"2017-03-01T07:50:43.461Z","comments":true,"path":"2016/02/06/经典电影排行/","link":"","permalink":"http://yoursite.com/2016/02/06/经典电影排行/","excerpt":"","text":"过年时间重温了几部电影，先简单写个列表 教父 教父 如果你身边有朋友告诉你，他／她看过几百遍《教父》，千万不要觉得惊奇，从某种意义上讲，她就像《红楼梦》一样，任何可以反复观看的作品都有她必然的道理。电影里所有的这一切都是以真实的情感作为基础的，没有任何的做作，没有任何的夸张，就像我们真实的生活一样，人对于真实其实是非常敏感的，我们对于编造的东西总是会有一种天生的觉察力，我们其实都能一眼分辨出什么是经历，什么是段子，因为真正动人的东西都是真实的，我们在看到《教父》当中这些琐碎的生活片段时都会那么的感动，因为这些片段和我们真实的生活产生了共鸣，合情合理（make sense）是感动的基础。 肖申克的救赎 肖申克的救赎 《肖申克的救赎》是一部1994年上映的美国经典剧情电影，改编自斯蒂芬·金《不同的季节》中收录的《丽塔海华丝及萧山克监狱的救赎》。电影讲述了安迪被冤入狱和在狱中的种种经历，并设法通过自己的救赎重新获得自由的故事。在1994年的奥斯卡金像奖上，本片获得七项提名，但最终未能获得任何奖项。令人意外的是，虽然该片在电影院公映时并未获得太多好评，但却在家庭影院市场和出租市场获得的巨大成功，至今已经成了著名案例。 辛德勒的名单 辛德勒的名单 第66届（1994年）奥斯卡最佳影片——《辛德勒的名单》（Schindler’sList）根据澳大利亚小说家托马斯·科内雅雷斯所著的《辛德勒名单》改编而成。史蒂文·斯皮尔伯格导演，真实的再现了德国企业家奥斯卡·辛德勒在第二次世界大战期间保护1200余名犹太人免遭法西斯杀害的真实的历史事件。 飞越疯人院 飞越疯人院 《飞越疯人院》（One Flew Over the Cuckoo’s Nest）是1975年美国导演米洛斯·福曼所拍摄电影，根据1962年肯·克西同名小说改编。该片是美国电影历史上最经典的电影之一，被称为“影视表演的必修课”；曾获1976年第48届奥斯卡最佳影片，最佳男、女主角，最佳导演和最佳改编剧本五项大奖。 …","categories":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/电影/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/tags/电影/"}]},{"title":"base标签","slug":"base标签","date":"2015-06-23T01:24:12.000Z","updated":"2017-02-28T12:19:13.603Z","comments":true,"path":"2015/06/23/base标签/","link":"","permalink":"http://yoursite.com/2015/06/23/base标签/","excerpt":"","text":"base标签的两个作用HTML中有一个base标签,我们可以通过该标签将需要加载的文件路径写成相对于项目的，而不是相对于当前页面的 代码如下 12345678&lt;html&gt;&lt;head&gt;&lt;base href=\"http://static.cnblogs.com/\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"./images/logo_gray.gif\" /&gt;&lt;/body&gt;&lt;/html&gt; 我们会发现，我们用相对路径./images/logo_gray.gif加载的图片，却变成了http://static.cnblogs.com/images/logo_gray.gif的图片。base标签可以给页面的链接加上默认的路径，或者默认的打开方式。下面是一个设置默认打开方式的例子：12345678&lt;html&gt;&lt;head&gt;&lt;base target=\"_blank\" /&gt;&lt;/head&gt;&lt;/p&gt; &lt;p&gt;&lt;body&gt;&lt;a href=\"http://www.cnblogs.com\"&gt;这个页面会在新窗口打开&lt;/a&gt;&lt;a href=\"http://justany.cnblogs.com\"&gt;这个页面也会在新窗口打开&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; base标签的BUGbase标签最好不要动态写入，否则在Firefox和IE中会有一个小bug，比如对于页面http://localhost/static/test.html：123456789&lt;html&gt;&lt;head&gt;&lt;script&gt;document.write('&lt;base href=\"http://localhost/\" /&gt;');&lt;/script&gt;&lt;/head&gt;&lt;/p&gt; &lt;p&gt;&lt;body&gt;&lt;img src=\"static/1.jpg\" /&gt;&lt;/body&gt;&lt;/html&gt; Firefox和IE中会先加载http://localhost/static/static/1.jpg，然后再加载http://localhost/static/1.jpg。也就是说，他们都先尝试用相对于当前页面的路径进行加载，然后再通过base标签设置的默认路径加载。而Chrome却能正常加载。 问题分析造成这种问题的原因可能是浏览器对资源加载进行了优化，导致动态插入base标签并未生效时，就预先去加载了，结果出错，然后base标签生效于是又加载正确的资源。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"hexo博客使用图片","slug":"hexo博客使用图片","date":"2015-03-02T00:23:21.000Z","updated":"2017-03-01T03:56:33.710Z","comments":true,"path":"2015/03/02/hexo博客使用图片/","link":"","permalink":"http://yoursite.com/2015/03/02/hexo博客使用图片/","excerpt":"","text":"之前使用base64解码图片，使用简单，但是一大片编码看着很乱，在网上发现CodeFalling/hexo-asset-image插件来加载本地图片。使用方法： 1.首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。2.在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save（需要等待一段时间）。3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。结构如下：12345本地图片测试├── apppicker.jpg├── logo.jpg└── rules.jpg本地图片测试.md 这样的目录结构（目录名和文章名一致），只要使用 ![logo](本地图片测试/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。生成的结构为12345public/2016/3/9/本地图片测试├── apppicker.jpg├── index.html├── logo.jpg└── rules.jpg 同时，生成的 html 是 &lt;img src=&quot;/2016/3/9/本地图片测试/logo.jpg&quot; alt=&quot;logo&quot;&gt;","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}